# Advent of Code - Day 12

```elixir
Mix.install([
  {:kino_aoc, "~> 0.1"}
  # {:eflambe_live, "~> 0.1.0"}
])
```

## Introduction

--> Content

## Puzzle

<!-- livebook:{"attrs":{"day":"12","session_secret":"AOC_SESSION","variable":"puzzle_input","year":"2023"},"chunks":null,"kind":"Elixir.KinoAOC.HelperCell","livebook_object":"smart_cell"} -->

```elixir
{:ok, puzzle_input} =
  KinoAOC.download_puzzle("2023", "12", System.fetch_env!("LB_AOC_SESSION"))
```

## Parser

### Code - Parser

```elixir
defmodule Parser do
  def parse(input) do
    String.split(input, "\n", trim: true)
    |> Enum.map(fn row ->
      [col, counts] = String.split(row, " ", trim: true)
      {col, String.split(counts, ",", trim: true) |> Enum.map(&String.to_integer(&1))}
    end)
  end
end
```

### Tests - Parser

```elixir
ExUnit.start(autorun: false)

defmodule ParserTest do
  use ExUnit.Case, async: true
  import Parser

  @input """
  ???.### 1,1,3
  .??..??...?##. 1,1,3
  ?#?#?#?#?#?#?#? 1,3,1,6
  ????.#...#... 4,1,1
  ????.######..#####. 1,6,5
  ?###???????? 3,2,1
  """

  @expected [
    {"???.###", [1, 1, 3]},
    {".??..??...?##.", [1, 1, 3]},
    {"?#?#?#?#?#?#?#?", [1, 3, 1, 6]},
    {"????.#...#...", [4, 1, 1]},
    {"????.######..#####.", [1, 6, 5]},
    {"?###????????", [3, 2, 1]}
  ]

  describe "parse/1" do
    test "simple example" do
      assert parse(@input) == @expected
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"branch_parent_index":2} -->

## Part One

### Code - Part 1

```elixir
defmodule PartOne do
  def solve(input) do
    IO.puts("--- Part One ---")
    IO.puts("Result: #{run(input)}")
  end

  def run(input_string) do
    Parser.parse(input_string)
    |> Enum.map(fn input_tuple ->
      # possibilities = possible_arrangements(input_tuple)
      # {_row, counts} = input_tuple
      # if Enum.any?(possibilities, fn poss -> String.length(poss) != String.length(hd(Tuple.to_list(input_tuple))) end) do
      # if Enum.any?(possibilities, fn poss -> 
      #   Regex.scan(~r/(\#+)/, poss) |> Enum.map(fn res -> hd(res) end) |> length() != length(counts)
      # end) do
      #   IO.inspect([input_tuple, possible_arrangements(input_tuple)], label: :input_tuple)    
      # end

      count_of_possible_arrangements(input_tuple)
    end)
    |> Enum.sum()
  end

  def count_of_possible_arrangements({row, counts}) do
    possible_arrangements({row, counts})
    |> length()
  end

  def possible_arrangements({row, counts}, res \\ "") do
    _possible_arrangements({row, counts}, res, hd(counts))
    |> List.flatten()
  end

  defp _possible_arrangements({row, counts}, res, current_count) when is_bitstring(row) do
    _possible_arrangements({String.split(row, "", trim: true), counts}, res, current_count)
  end

  defp _possible_arrangements({row, counts}, res, current_count) do
    # IO.inspect([{row, counts}, res, current_count], label: :_possible_arrangements_input)
    # [{["#", "?"], []}, "#..########.#", nil]
    cond do
      Enum.empty?(row) && !Enum.empty?(counts) ->
        []

      !Enum.empty?(row) && Enum.empty?(counts) && "#" in row ->
        []

      Enum.empty?(row) && Enum.empty?(counts) ->
        res

      Enum.empty?(counts) && "#" not in row ->
        res <> (Enum.join(row) |> String.replace("?", "."))

      # _possible_arrangements_input: [{[".", "?", "?", "?", "#"], [2, 1]}, ".#######.#.#", 1]

      hd(row) == "." && current_count != hd(counts) ->
        []

      hd(row) == "#" && String.last(res) == "#" && current_count == hd(counts) ->
        []

      true ->
        possible_branches =
          cond do
            hd(row) == "#" ->
              [{tl(row), counts, res <> "#", current_count - 1}]

            hd(row) == "?" && String.last(res) == "#" && current_count == hd(counts) ->
              [{tl(row), counts, res <> ".", current_count}]

            hd(row) == "?" && current_count != hd(counts) ->
              [{tl(row), counts, res <> "#", current_count - 1}]

            hd(row) == "?" ->
              [
                {tl(row), counts, res <> "#", current_count - 1},
                {tl(row), counts, res <> ".", current_count}
              ]

            true ->
              [{tl(row), counts, res <> ".", current_count}]
          end

        Enum.map(possible_branches, fn {row_remaining, counts_remaining, res, current_count} ->
          {counts_remaining, current_count} =
            if current_count <= 0 do
              {tl(counts_remaining), List.first(tl(counts_remaining))}
            else
              {counts_remaining, current_count}
            end

          _possible_arrangements({row_remaining, counts_remaining}, res, current_count)
        end)
    end
  end
end
```

### Tests - Part 1

```elixir
ExUnit.start(autorun: false)

defmodule PartOneTest do
  use ExUnit.Case, async: true
  import PartOne

  @raw_input """
  ???.### 1,1,3
  .??..??...?##. 1,1,3
  ?#?#?#?#?#?#?#? 1,3,1,6
  ????.#...#... 4,1,1
  ????.######..#####. 1,6,5
  ?###???????? 3,2,1
  """

  # describe "run/1" do
  #   test "main example" do
  #     assert run(@raw_input) == 21
  #   end
  # end

  describe "possible_arrangements/2" do
    test "test 1" do
      actual = possible_arrangements({"???.###", [1, 1, 3]})
      assert actual == ["#.#.###"]
    end

    test "test 2" do
      actual = possible_arrangements({".??..??...?##.", [1, 1, 3]})
      assert actual == [".#...#....###.", ".#....#...###.", "..#..#....###.", "..#...#...###."]
    end

    test "test 3" do
      actual = possible_arrangements({"?#?#?#?#?#?#?#?", [1, 3, 1, 6]})
      assert actual == [".#.###.#.######"]
    end

    test "test 4" do
      actual = possible_arrangements({"????.#...#...", [4, 1, 1]})
      assert actual == ["####.#...#..."]
    end

    test "test 5" do
      actual = possible_arrangements({"????.######..#####.", [1, 6, 5]})

      assert actual == [
               "#....######..#####.",
               ".#...######..#####.",
               "..#..######..#####.",
               "...#.######..#####."
             ]
    end

    test "test 6" do
      actual = possible_arrangements({"?###????????", [3, 2, 1]})

      assert actual == [
               ".###.##.#...",
               ".###.##..#..",
               ".###.##...#.",
               ".###.##....#",
               ".###..##.#..",
               ".###..##..#.",
               ".###..##...#",
               ".###...##.#.",
               ".###...##..#",
               ".###....##.#"
             ]
    end

    test "from example input" do
      actual = possible_arrangements({".?#?#?##??.#.???#", [7, 1, 2, 1]})

      assert actual == [
               ".#######...#.##.#",
               "..#######..#.##.#"
             ]
    end
  end
end

ExUnit.run()
```

### Solution - Part 1

```elixir
PartOne.solve(puzzle_input)
# Parser.parse(puzzle_input) |> Enum.filter(fn {line, _} -> !String.contains?(line, "#") end)
```

<!-- livebook:{"branch_parent_index":2} -->

## Part Two

### Code - Part 2

```elixir
defmodule PartTwo do
  require Integer, [:is_odd, :is_even]

  def solve(input) do
    IO.puts("--- Part Two ---")
    IO.puts("Result: #{run(input)}")
  end

  def run(input_string) do
    Parser.parse(input_string)
    |> Enum.with_index()
    |> Enum.map(fn {input_tuple, index} ->
      IO.inspect(index)
      IO.inspect(input_tuple, label: :input)
      count = count_of_possible_arrangements(input_tuple)
      IO.inspect(count, label: :count)
    end)
    |> Enum.sum()
  end

  def count_of_possible_arrangements({row, counts}, loops \\ 5) do
    possibilities = possible_arrangements({row, counts}, loops)

    cond do
      {_res, _count} = hd(possibilities) ->
        possibilities |> Enum.reduce(0, fn {_res, count}, sum -> sum + count end)

      true ->
        possibilities |> length()
    end
  end

  def possible_arrangements({row, counts}) do
    possible_arrangements({row, counts}, 5)
  end

  def possible_arrangements({row, counts}, loops) when is_bitstring(row) do
    possible_arrangements({String.split(row, "", trim: true), counts}, loops)
  end

  def possible_arrangements({original_row, original_counts}, loops) do
    first_input = {{{[], []}, "", hd(original_counts), ""}, 1}
    # IO.inspect(first_input, label: :first_res_list)

    {outputs, _} =
      Enum.reduce(1..loops, {[first_input], %{}}, fn loop, {res_list, cache} ->
        IO.inspect(loop, label: :loop_count)
        # IO.inspect(Enum.count(cache), label: :cache_count)
        # IO.inspect(:erts_debug.size(cache), label: :cache_size)
        IO.puts("computing inspection...")

        IO.inspect(
          {:erts_debug.size(res_list), res_list |> Enum.count(),
           Enum.uniq(res_list) |> Enum.count()},
          label: :res_list_size_count_uniqcount
        )

        # IO.inspect(res_list, label: :res_list)
        # IO.inspect(cache, label: :cache)

        {in_outs_tuple, new_cache} =
          Enum.reduce(res_list, {[], cache}, fn {{{remaining_row, remaining_counts}, _local_res,
                                                  current_count, prev_res_elem}, count},
                                                {inner_outputs, inner_cache} ->
            next_row =
              if loop > 1 do
                remaining_row ++ ["?"] ++ original_row
              else
                remaining_row ++ original_row
              end

            next_counts = remaining_counts ++ original_counts

            inner_input =
              {{next_row, next_counts}, "", current_count || hd(next_counts), prev_res_elem}

            # IO.inspect(inner_input, label: :inner_input_____)

            inner_input_for_cache =
              {{next_row, next_counts}, current_count || hd(next_counts), prev_res_elem}

            new_inner_outputs =
              if Map.has_key?(inner_cache, inner_input_for_cache) do
                # IO.puts("cache hit :)")
                inner_cache[inner_input_for_cache]
                |> Enum.map(fn {{{remaining_row, remaining_counts}, local_res, current_count,
                                 prev_res_elem}, count_in_cache} ->
                  {{{remaining_row, remaining_counts}, local_res, current_count, prev_res_elem},
                   count_in_cache * count}
                end)
              else
                # IO.puts("cache miss :(")
                _possible_arrangements(inner_input)
                |> List.flatten()
                |> Enum.group_by(fn v -> v end)
                |> Enum.map(fn {k, v} -> {k, Enum.count(v) * count} end)
              end

            new_inner_cache =
              if Map.has_key?(inner_cache, inner_input_for_cache) do
                inner_cache
              else
                inner_outputs_for_cache =
                  new_inner_outputs
                  |> Enum.map(fn {main, output_count} ->
                    {main, div(output_count, count)}
                  end)

                Map.put_new(inner_cache, inner_input_for_cache, inner_outputs_for_cache)
              end

            {[{inner_input_for_cache, new_inner_outputs} | inner_outputs], new_inner_cache}
          end)

        outputs =
          in_outs_tuple
          |> List.flatten()
          |> Enum.map(fn {_inner_input, inner_outputs} -> inner_outputs end)
          |> List.flatten()
          |> merge_similar_outputs()

        {outputs, new_cache}
      end)

    IO.puts("computing inspection...")

    IO.inspect(
      {:erts_debug.size(outputs), outputs |> Enum.count(), Enum.uniq(outputs) |> Enum.count()},
      label: :outputs_size_count_uniqcount
    )

    v1 =
      outputs
      |> Enum.filter(fn {{{remaining_row, remaining_counts}, _local_res, _current_count,
                          _prev_res_elem}, _count} ->
        # IO.inspect({{remaining_row, remaining_counts}, local_res, current_count, prev_res_elem})
        Enum.empty?(remaining_counts) && "#" not in remaining_row
      end)

    IO.puts("computing inspection...")

    IO.inspect({:erts_debug.size(v1), v1 |> Enum.count(), Enum.uniq(v1) |> Enum.count()},
      label: :v1_size_count_uniqcount
    )

    v2 =
      v1
      |> Enum.map(fn {{{remaining_row, _remaining_counts}, local_res, _current_count,
                       _prev_res_elem}, count} ->
        # IO.inspect({{remaining_row, remaining_counts}, res, local_res, current_count, prev_res_elem}, label: :mappingoutput)
        {local_res <> (Enum.join(remaining_row) |> String.replace("?", ".")), count}
      end)

    IO.puts("computing inspection...")

    IO.inspect({:erts_debug.size(v2), v2 |> Enum.count(), Enum.uniq(v2) |> Enum.count()},
      label: :v2_size_count_uniqcount
    )

    v2
    # v3 = v2 |> Enum.reduce([], fn {res, count}, acc -> 
    #   Enum.map(1..count, fn _ -> res end) ++ acc
    # end)

    # IO.puts("computing inspection...")
    # IO.inspect({:erts_debug.size(v3), v3 |> Enum.count, Enum.uniq(v3) |> Enum.count}, label: :v3_size_count_uniqcount) 

    # v3
  end

  defp merge_similar_outputs(data) do
    data
    |> Enum.frequencies()
    |> Enum.map(fn {{tuple, output_count}, freq} -> {tuple, output_count * freq} end)
  end

  defp _possible_arrangements({{row, counts}, local_res, current_count, prev_res_elem}) do
    cond do
      Enum.empty?(row) || Enum.empty?(counts) ->
        {{row, counts}, local_res, current_count, prev_res_elem}

      hd(row) == "." && current_count != hd(counts) ->
        []

      hd(row) == "#" && prev_res_elem == "#" && current_count == hd(counts) ->
        []

      true ->
        possible_branches =
          cond do
            hd(row) == "#" ->
              [{tl(row), counts, local_res <> "#", current_count - 1}]

            hd(row) == "?" && prev_res_elem == "#" && current_count == hd(counts) ->
              [{tl(row), counts, local_res <> ".", current_count}]

            hd(row) == "?" && current_count != hd(counts) ->
              [{tl(row), counts, local_res <> "#", current_count - 1}]

            hd(row) == "?" ->
              [
                {tl(row), counts, local_res <> "#", current_count - 1},
                {tl(row), counts, local_res <> ".", current_count}
              ]

            true ->
              [{tl(row), counts, local_res <> ".", current_count}]
          end

        Enum.map(possible_branches, fn {row_remaining, counts_remaining, local_res, current_count} ->
          {counts_remaining, current_count} =
            if current_count <= 0 do
              {tl(counts_remaining), List.first(tl(counts_remaining))}
            else
              {counts_remaining, current_count}
            end

          _possible_arrangements(
            {{row_remaining, counts_remaining}, local_res, current_count, String.last(local_res)}
          )
        end)
    end
  end
end
```

### Tests - Part 2

```elixir
ExUnit.start(autorun: false)

defmodule PartTwoTest do
  use ExUnit.Case, async: true
  import PartTwo

  @raw_input """
  ???.### 1,1,3
  .??..??...?##. 1,1,3
  ?#?#?#?#?#?#?#? 1,3,1,6
  ????.#...#... 4,1,1
  ????.######..#####. 1,6,5
  ?###???????? 3,2,1
  """

  # @raw_input """
  # ???.### 1,1,3
  # ?#?#?#?#?#?#?#? 1,3,1,6
  # ????.#...#... 4,1,1
  # ????.######..#####. 1,6,5
  # """

  # describe "run/1" do
  #   test "main example" do
  #     assert run(@raw_input) == 525_152
  #     # assert run(@raw_input) == 18902
  #     # assert run(@raw_input) == 2518
  #   end
  # end

  describe "count_of_possible_arrangements/2" do
    # test "test 1" do
    #   actual = count_of_possible_arrangements({"???.###", [1, 1, 3]})
    #   assert actual == 1
    # end

    # test "test 2" do
    #   actual = count_of_possible_arrangements({".??..??...?##.", [1, 1, 3]})
    #   assert actual == 16384
    # end

    # test "test 3" do
    #   actual = count_of_possible_arrangements({"?#?#?#?#?#?#?#?", [1, 3, 1, 6]})
    #   assert actual == 1
    # end

    # test "test 4" do
    #   actual = count_of_possible_arrangements({"????.#...#...", [4, 1, 1]})
    #   assert actual == 16
    # end

    # test "test 5" do
    #   actual = count_of_possible_arrangements({"????.######..#####.", [1, 6, 5]})
    #   assert actual == 2500
    # end

    # test "test 6" do
    #   actual = count_of_possible_arrangements({"?###????????", [3, 2, 1]})
    #   assert actual == 506_250
    #   # loop_count: 5
    #   # res_list_count: 11250
    #   # cache_count: 9
    #   # cache_size: 2572
    #   # res_list_size: 125359
    #   # res_list_uniq_count: 11250
    # end

    # test "from example input - one that gets stuck" do
    #   actual = count_of_possible_arrangements({"??#??#????????",      [1, 5, 1]}, 5)
    # end

    test "from example input - last loop takes a few seconds" do
      actual = count_of_possible_arrangements({"???????????.", [2, 2]}, 5)
    end
  end

  # describe "possible_arrangements considering only a single loop" do
  #   test "test 1" do
  #     actual = possible_arrangements({"???.###", [1, 1, 3]}, 1)
  #     assert actual == [{"#.#.###", 1}]
  #   end

  #   test "test 2" do
  #     actual = possible_arrangements({".??..??...?##.", [1, 1, 3]}, 1)
  #     assert Enum.sort(actual) == [{".#...#....###.", 1}, {".#....#...###.", 1}, {"..#..#....###.", 1}, {"..#...#...###.", 1}]
  #   end

  #   test "test 3" do
  #     actual = possible_arrangements({"?#?#?#?#?#?#?#?", [1, 3, 1, 6]}, 1)
  #     assert actual == [{".#.###.#.######", 1}]
  #   end

  #   test "test 4" do
  #     actual = possible_arrangements({"????.#...#...", [4, 1, 1]}, 1)
  #     assert actual == [{"####.#...#...", 1}]
  #   end

  #   test "test 5" do
  #     actual = possible_arrangements({"????.######..#####.", [1, 6, 5]}, 1)

  #     assert Enum.sort(actual) == [
  #              {"#....######..#####.", 1},
  #              {".#...######..#####.", 1},
  #              {"..#..######..#####.", 1},
  #              {"...#.######..#####.", 1},
  #            ]
  #   end

  #   test "test 6" do
  #     actual = possible_arrangements({"?###????????", [3, 2, 1]}, 1)

  #     assert Enum.sort(actual) == [
  #              {".###.##.#...", 1},
  #              {".###.##..#..", 1},
  #              {".###.##...#.", 1},
  #              {".###.##....#", 1},
  #              {".###..##.#..", 1},
  #              {".###..##..#.", 1},
  #              {".###..##...#", 1},
  #              {".###...##.#.", 1},
  #              {".###...##..#", 1},
  #              {".###....##.#", 1},
  #            ]
  #   end

  #   # test "from example input" do
  #   #   actual = possible_arrangements({".?#?#?##??.#.???#", [7, 1, 2, 1]}, 1)

  #   #   assert Enum.sort(actual) == [
  #   #            {".#######...#.##.#", 1},
  #   #            {"..#######..#.##.#", 1}
  #   #          ]
  #   # end
  # end
end

ExUnit.run()
```

### Solution - Part 2

```elixir
PartTwo.solve(puzzle_input)
```

<!-- livebook:{"offset":18805,"stamp":{"token":"XCP.sIbLXwt3qGLHKYWDGqMHR4jvQWkX5V1fCdpIMXTiU7mjmK56QFryOYJwGWmwpzPfMRu0aNxmlMsM7Z9ZTti5b_9u8BcJJPYpHe8FGQYOPipKBJtmBwM","version":2}} -->
