# Advent of Code - Day 12

```elixir
Mix.install([
  {:kino_aoc, "~> 0.1"}
])
```

## Introduction

--> Content

## Puzzle

<!-- livebook:{"attrs":{"assign_to":"puzzle_input","day":"12","session_secret":"AOC_SESSION","year":"2023"},"chunks":null,"kind":"Elixir.KinoAOC.HelperCell","livebook_object":"smart_cell"} -->

```elixir
{:ok, puzzle_input} =
  KinoAOC.download_puzzle("2023", "12", System.fetch_env!("LB_AOC_SESSION"))
```

## Parser

### Code - Parser

```elixir
defmodule Parser do
  def parse(input) do
    String.split(input, "\n", trim: true)
    |> Enum.map(fn row ->
      [col, counts] = String.split(row, " ", trim: true)
      {col, String.split(counts, ",", trim: true) |> Enum.map(&String.to_integer(&1))}
    end)
  end
end
```

### Tests - Parser

```elixir
ExUnit.start(autorun: false)

defmodule ParserTest do
  use ExUnit.Case, async: true
  import Parser

  @input """
  ???.### 1,1,3
  .??..??...?##. 1,1,3
  ?#?#?#?#?#?#?#? 1,3,1,6
  ????.#...#... 4,1,1
  ????.######..#####. 1,6,5
  ?###???????? 3,2,1
  """

  @expected [
    {"???.###", [1, 1, 3]},
    {".??..??...?##.", [1, 1, 3]},
    {"?#?#?#?#?#?#?#?", [1, 3, 1, 6]},
    {"????.#...#...", [4, 1, 1]},
    {"????.######..#####.", [1, 6, 5]},
    {"?###????????", [3, 2, 1]}
  ]

  describe "parse/1" do
    test "simple example" do
      assert parse(@input) == @expected
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"branch_parent_index":2} -->

## Part One

### Code - Part 1

```elixir
defmodule PartOne do
  def solve(input) do
    IO.puts("--- Part One ---")
    IO.puts("Result: #{run(input)}")
  end

  def run(input_string) do
    Parser.parse(input_string)
    |> Enum.map(fn input_tuple ->
      # possibilities = possible_arrangements(input_tuple)
      # {_row, counts} = input_tuple
      # if Enum.any?(possibilities, fn poss -> String.length(poss) != String.length(hd(Tuple.to_list(input_tuple))) end) do
      # if Enum.any?(possibilities, fn poss -> 
      #   Regex.scan(~r/(\#+)/, poss) |> Enum.map(fn res -> hd(res) end) |> length() != length(counts)
      # end) do
      #   IO.inspect([input_tuple, possible_arrangements(input_tuple)], label: :input_tuple)    
      # end

      count_of_possible_arrangements(input_tuple)
    end)
    |> Enum.sum()
  end

  def count_of_possible_arrangements({row, counts}) do
    possible_arrangements({row, counts})
    |> length()
  end

  def possible_arrangements({row, counts}, res \\ "") do
    _possible_arrangements({row, counts}, res, hd(counts))
    |> List.flatten()
  end

  defp _possible_arrangements({row, counts}, res, current_count) when is_bitstring(row) do
    _possible_arrangements({String.split(row, "", trim: true), counts}, res, current_count)
  end

  defp _possible_arrangements({row, counts}, res, current_count) do
    # IO.inspect([{row, counts}, res, current_count], label: :_possible_arrangements_input)
    # [{["#", "?"], []}, "#..########.#", nil]
    cond do
      Enum.empty?(row) && !Enum.empty?(counts) ->
        []

      !Enum.empty?(row) && Enum.empty?(counts) && "#" in row ->
        []

      Enum.empty?(row) && Enum.empty?(counts) ->
        res

      Enum.empty?(counts) && "#" not in row ->
        res <> (Enum.join(row) |> String.replace("?", "."))

      # _possible_arrangements_input: [{[".", "?", "?", "?", "#"], [2, 1]}, ".#######.#.#", 1]

      hd(row) == "." && current_count != hd(counts) ->
        []

      hd(row) == "#" && String.last(res) == "#" && current_count == hd(counts) ->
        []

      true ->
        possible_branches =
          cond do
            hd(row) == "#" ->
              [{tl(row), counts, res <> "#", current_count - 1}]

            hd(row) == "?" && String.last(res) == "#" && current_count == hd(counts) ->
              [{tl(row), counts, res <> ".", current_count}]

            hd(row) == "?" && current_count != hd(counts) ->
              [{tl(row), counts, res <> "#", current_count - 1}]

            hd(row) == "?" ->
              [
                {tl(row), counts, res <> "#", current_count - 1},
                {tl(row), counts, res <> ".", current_count}
              ]

            true ->
              [{tl(row), counts, res <> ".", current_count}]
          end

        Enum.map(possible_branches, fn {row_remaining, counts_remaining, res, current_count} ->
          {counts_remaining, current_count} =
            if current_count <= 0 do
              {tl(counts_remaining), List.first(tl(counts_remaining))}
            else
              {counts_remaining, current_count}
            end

          _possible_arrangements({row_remaining, counts_remaining}, res, current_count)
        end)
    end
  end
end
```

### Tests - Part 1

```elixir
ExUnit.start(autorun: false)

defmodule PartOneTest do
  use ExUnit.Case, async: true
  import PartOne

  @raw_input """
  ???.### 1,1,3
  .??..??...?##. 1,1,3
  ?#?#?#?#?#?#?#? 1,3,1,6
  ????.#...#... 4,1,1
  ????.######..#####. 1,6,5
  ?###???????? 3,2,1
  """

  # describe "run/1" do
  #   test "main example" do
  #     assert run(@raw_input) == 21
  #   end
  # end

  describe "possible_arrangements/2" do
    test "test 1" do
      actual = possible_arrangements({"???.###", [1, 1, 3]})
      assert actual == ["#.#.###"]
    end

    test "test 2" do
      actual = possible_arrangements({".??..??...?##.", [1, 1, 3]})
      assert actual == [".#...#....###.", ".#....#...###.", "..#..#....###.", "..#...#...###."]
    end

    test "test 3" do
      actual = possible_arrangements({"?#?#?#?#?#?#?#?", [1, 3, 1, 6]})
      assert actual == [".#.###.#.######"]
    end

    test "test 4" do
      actual = possible_arrangements({"????.#...#...", [4, 1, 1]})
      assert actual == ["####.#...#..."]
    end

    test "test 5" do
      actual = possible_arrangements({"????.######..#####.", [1, 6, 5]})

      assert actual == [
               "#....######..#####.",
               ".#...######..#####.",
               "..#..######..#####.",
               "...#.######..#####."
             ]
    end

    test "test 6" do
      actual = possible_arrangements({"?###????????", [3, 2, 1]})

      assert actual == [
               ".###.##.#...",
               ".###.##..#..",
               ".###.##...#.",
               ".###.##....#",
               ".###..##.#..",
               ".###..##..#.",
               ".###..##...#",
               ".###...##.#.",
               ".###...##..#",
               ".###....##.#"
             ]
    end

    test "from example input" do
      actual = possible_arrangements({".?#?#?##??.#.???#", [7, 1, 2, 1]})

      assert actual == [
               ".#######...#.##.#",
               "..#######..#.##.#"
             ]
    end
  end
end

ExUnit.run()
```

### Solution - Part 1

```elixir
PartOne.solve(puzzle_input)
# Parser.parse(puzzle_input) |> Enum.filter(fn {line, _} -> !String.contains?(line, "#") end)
```

<!-- livebook:{"branch_parent_index":2} -->

## Part Two

### Code - Part 2

```elixir
defmodule PartTwo do
  require Integer, [:is_odd, :is_even]

  def solve(input) do
    IO.puts("--- Part Two ---")
    IO.puts("Result: #{run(input)}")
  end

  def run(input_string) do
    Parser.parse(input_string)
    |> Enum.with_index()
    |> Enum.map(fn {input_tuple, index} ->
      IO.inspect(index)
      IO.inspect(input_tuple, label: :input)
      count = count_of_possible_arrangements(input_tuple)
      IO.inspect(count, label: :count)
    end)
    |> Enum.sum()
  end

  def count_of_possible_arrangements({row, counts}) do
    possible_arrangements({row, counts})
    |> length()
  end

  def possible_arrangements({row, counts}) do
    possible_arrangements({row, counts}, 5)
  end

  def possible_arrangements({row, counts}, loops) when is_bitstring(row) do
    possible_arrangements({String.split(row, "", trim: true), counts}, loops)
  end

  def possible_arrangements({original_row, original_counts}, loops) do
    first_input = {{[], []}, "", "", hd(original_counts), ""}
    # IO.inspect(first_input, label: :first_res_list)

    {outputs, _} =
      Enum.reduce(1..loops, {[first_input], %{}}, fn loop, {res_list, cache} ->
        # IO.inspect(loop, label: :loop_count)
        # IO.inspect(Enum.count(cache), label: :cache_count)

        {in_outs_tuple, new_cache} =
          Enum.reduce(res_list, {[], cache}, fn {{remaining_row, remaining_counts}, res,
                                                 _local_res, current_count, prev_res_elem},
                                                {inner_outputs, inner_cache} ->
            next_row =
              if loop > 1 do
                remaining_row ++ ["?"] ++ original_row
              else
                remaining_row ++ original_row
              end

            next_counts = remaining_counts ++ original_counts

            inner_input =
              {{next_row, next_counts}, res, "", current_count || hd(next_counts), prev_res_elem}

            inner_input_for_cache =
              {{next_row, next_counts}, current_count || hd(next_counts), prev_res_elem}

            new_inner_outputs =
              if Map.has_key?(inner_cache, inner_input_for_cache) do
                # IO.puts("cache hit :)")
                inner_cache[inner_input_for_cache]
                |> Enum.map(fn {{remaining_row, remaining_counts}, local_res, current_count,
                                prev_res_elem} ->
                  {{remaining_row, remaining_counts}, res, local_res, current_count,
                   prev_res_elem}
                end)
              else
                # IO.puts("cache miss :(")
                _possible_arrangements(inner_input) |> List.flatten()
              end

            new_inner_cache =
              if Map.has_key?(inner_cache, inner_input_for_cache) do
                inner_cache
              else
                inner_outputs_for_cache =
                  new_inner_outputs
                  |> Enum.map(fn {{remaining_row2, remaining_counts2}, _res2, local_res2,
                                  current_count2, prev_res_elem2} ->
                    {{remaining_row2, remaining_counts2}, local_res2, current_count2,
                     prev_res_elem2}
                  end)

                Map.put_new(inner_cache, inner_input_for_cache, inner_outputs_for_cache)
              end

            {[{inner_input_for_cache, new_inner_outputs} | inner_outputs], new_inner_cache}
          end)

        outputs =
          in_outs_tuple
          |> List.flatten()
          |> Enum.map(fn {_inner_input, inner_outputs} -> inner_outputs end)
          |> List.flatten()

        {outputs, new_cache}
      end)

    outputs
    |> Enum.filter(fn {{remaining_row, remaining_counts}, _res, _local_res, _current_count,
                       _prev_res_elem} ->
      # IO.inspect({{remaining_row, remaining_counts}, res, local_res, current_count, prev_res_elem})
      Enum.empty?(remaining_counts) && "#" not in remaining_row
    end)
    |> Enum.map(fn {{remaining_row, _remaining_counts}, res, _local_res, _current_count,
                    _prev_res_elem} ->
      # IO.inspect({{remaining_row, remaining_counts}, res, local_res, current_count, prev_res_elem}, label: :mappingoutput)
      res <> (Enum.join(remaining_row) |> String.replace("?", "."))
    end)
  end

  defp _possible_arrangements({{row, counts}, res, local_res, current_count, prev_res_elem}) do
    cond do
      Enum.empty?(row) || Enum.empty?(counts) ->
        {{row, counts}, res, local_res, current_count, prev_res_elem}

      hd(row) == "." && current_count != hd(counts) ->
        []

      hd(row) == "#" && prev_res_elem == "#" && current_count == hd(counts) ->
        []

      true ->
        possible_branches =
          cond do
            hd(row) == "#" ->
              [{tl(row), counts, res <> "#", local_res <> "#", current_count - 1}]

            hd(row) == "?" && prev_res_elem == "#" && current_count == hd(counts) ->
              [{tl(row), counts, res <> ".", local_res <> ".", current_count}]

            hd(row) == "?" && current_count != hd(counts) ->
              [{tl(row), counts, res <> "#", local_res <> "#", current_count - 1}]

            hd(row) == "?" ->
              [
                {tl(row), counts, res <> "#", local_res <> "#", current_count - 1},
                {tl(row), counts, res <> ".", local_res <> ".", current_count}
              ]

            true ->
              [{tl(row), counts, res <> ".", local_res <> ".", current_count}]
          end

        Enum.map(possible_branches, fn {row_remaining, counts_remaining, res, local_res,
                                        current_count} ->
          {counts_remaining, current_count} =
            if current_count <= 0 do
              {tl(counts_remaining), List.first(tl(counts_remaining))}
            else
              {counts_remaining, current_count}
            end

          _possible_arrangements(
            {{row_remaining, counts_remaining}, res, local_res, current_count, String.last(res)}
          )
        end)
    end
  end
end
```

### Tests - Part 2

```elixir
ExUnit.start(autorun: false)

defmodule PartTwoTest do
  use ExUnit.Case, async: true
  import PartTwo

  @raw_input """
  ???.### 1,1,3
  .??..??...?##. 1,1,3
  ?#?#?#?#?#?#?#? 1,3,1,6
  ????.#...#... 4,1,1
  ????.######..#####. 1,6,5
  ?###???????? 3,2,1
  """

  # @raw_input """
  # ???.### 1,1,3
  # ?#?#?#?#?#?#?#? 1,3,1,6
  # ????.#...#... 4,1,1
  # ????.######..#####. 1,6,5
  # """

  describe "run/1" do
    test "main example" do
      assert run(@raw_input) == 525_152
      # assert run(@raw_input) == 18902
      # assert run(@raw_input) == 2518
    end
  end

  describe "count_of_possible_arrangements/2" do
    test "test 1" do
      actual = count_of_possible_arrangements({"???.###", [1, 1, 3]})
      assert actual == 1
    end

    test "test 2" do
      actual = count_of_possible_arrangements({".??..??...?##.", [1, 1, 3]})
      assert actual == 16384
    end

    test "test 3" do
      actual = count_of_possible_arrangements({"?#?#?#?#?#?#?#?", [1, 3, 1, 6]})
      assert actual == 1
    end

    test "test 4" do
      actual = count_of_possible_arrangements({"????.#...#...", [4, 1, 1]})
      assert actual == 16
    end

    test "test 5" do
      actual = count_of_possible_arrangements({"????.######..#####.", [1, 6, 5]})
      assert actual == 2500
    end

    test "test 6" do
      actual = count_of_possible_arrangements({"?###????????", [3, 2, 1]})
      assert actual == 506_250
    end
  end

  describe "possible_arrangements considering only a single loop" do
    test "test 1" do
      actual = possible_arrangements({"???.###", [1, 1, 3]}, 1)
      assert actual == ["#.#.###"]
    end

    test "test 2" do
      actual = possible_arrangements({".??..??...?##.", [1, 1, 3]}, 1)
      assert actual == [".#...#....###.", ".#....#...###.", "..#..#....###.", "..#...#...###."]
    end

    test "test 3" do
      actual = possible_arrangements({"?#?#?#?#?#?#?#?", [1, 3, 1, 6]}, 1)
      assert actual == [".#.###.#.######"]
    end

    test "test 4" do
      actual = possible_arrangements({"????.#...#...", [4, 1, 1]}, 1)
      assert actual == ["####.#...#..."]
    end

    test "test 5" do
      actual = possible_arrangements({"????.######..#####.", [1, 6, 5]}, 1)

      assert actual == [
               "#....######..#####.",
               ".#...######..#####.",
               "..#..######..#####.",
               "...#.######..#####."
             ]
    end

    test "test 6" do
      actual = possible_arrangements({"?###????????", [3, 2, 1]}, 1)

      assert actual == [
               ".###.##.#...",
               ".###.##..#..",
               ".###.##...#.",
               ".###.##....#",
               ".###..##.#..",
               ".###..##..#.",
               ".###..##...#",
               ".###...##.#.",
               ".###...##..#",
               ".###....##.#"
             ]
    end

    test "from example input" do
      actual = possible_arrangements({".?#?#?##??.#.???#", [7, 1, 2, 1]}, 1)

      assert actual == [
               ".#######...#.##.#",
               "..#######..#.##.#"
             ]
    end
  end
end

ExUnit.run()
```

### Solution - Part 2

```elixir
PartTwo.solve(puzzle_input)
```

<!-- livebook:{"offset":16279,"stamp":{"token":"XCP.uoVdnmR7q9trUaQwpdjLVf_bNCpjokNKnLwablyYs_vq7tpIKEENLXUqEA-Ql5tvpfjCnqcNgfcqn93t3EJzl9DgGAqXCoVp2eb2quJ53uLOj_DRbkI","version":2}} -->
